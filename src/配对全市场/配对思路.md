下面给出一份“可直接落地”的 A 股多头轮动排序框架，完全围绕你提出的两个硬指标：
① 协整必须显著（Engle-Granger 或 Johansen p<0.05）；
② 价差必须“回得够快”——OU 半衰期 < 3 个月（≈60 个交易日）。

一、准备池子（可交易日频调仓）
股票：同一申万二级行业且市值前 2000 的龙头；
ETF：日均成交量大于1000万；
可转债：剩余规模>5 亿、成交>1000 万元；
把以上放到一个池子，先做成“对”而不是“单只”——N 个标的先两两组合，得到 C(N,2) 个候选对子。
二、快速初筛（减少 90% 计算量）
过去 250 日收盘价 Pearson ρ ≥ 0.85；
价差年化波动率 < 25%（防止高噪）；
两只标的日均成交额均 > 1千万（保证调仓能成交）。
满足 3 条才进入下一步协整/OU 环节。
三、协整检验（必须过）
3.1 Engle-Granger 两步法

from statsmodels.tsa.stattools import coint
score, p, _ = coint(y, x) # y、x 为对数收盘价
要求 p < 0.05；
同时保留 β 系数，用于构造价差：
z = log(P_y) – β·log(P_x)。

四、Ornstein-Uhlenbeck 参数估计 + 半衰期
4.1 离散形式
z_t = α + φ·z_{t-1} + ε_t, ε_t ~ N(0,σ²)
4.2 φ估计方法

Kalman Filter（时变 φ，抗异常值）

from pykalman import KalmanFilter
kf = KalmanFilter(transition_matrices=[[1]], observation_matrices=[[1]],
 initial_state_mean=0, initial_state_covariance=1,
 observation_covariance=1, transition_covariance=.01)
state_means, _ = kf.filter(z.values)

4.3 半衰期公式
H = -ln(2)/ln|φ| （单位：交易日）
硬门槛：H < 60 日；
优选区：H 15–40 日（太短会频繁误判，太长资金效率低）。


五、排序打分函数（把“协整”与“回速”量化到同一标尺）
对每对通过检验的组合，计算：
Score = 100 × max(0, 1 − p_value) + 50 × max(0, 1 − H/60)
p_value 来自协整检验；
H 为 OU 半衰期；
两项权重 2:1，既保证“关系稳”，又奖励“回得快”。
把 Score 降序排列。


六、样本外持续监控（这个不实现）
滚动窗口：每周五收盘后用最近 250 日重跑全流程；
关系断裂预警：
若最新 60 日滚动 ρ 跌破 0.75，或
新 p_value > 0.1，或
最新 H > 90 日
立即把该对移出交易池，并平仓。
七、落地交易逻辑（份额最大化）（这个不实现）
底仓始终 100% 多头，只在配对内部调仓；
阈值：z 偏离 μ ± 1.2σ 开始轮动，± 0.2σ 回归中心再平衡；
调仓比例：Δw = (z − μ)/σ × 0.3（防止一次打满）；
交易费用：双边 0.15% 以内即可覆盖（ETF 申赎可 0 佣金）。
八、参考代码片段（可直接跑）

import pandas as pd, numpy as np
from statsmodels.tsa.stattools import coint
from pykalman import KalmanFilter
def ou_half_life(s):
 s = s.dropna()
 z = s - s.mean()

# Kalman 平滑

 kf = KalmanFilter(transition_matrices=[[1]],
 observation_matrices=[[1]],
 initial_state_mean=0, initial_state_covariance=1,
 observation_covariance=1, transition_covariance=.01)
 z_filt, _ = kf.filter(z.values)
 z_filt = z_filt.flatten()

# OLS 求 φ

 x = z_filt[:-1]; y = z_filt[1:]
 phi = np.linalg.lstsq(x[:,None], y, rcond=None)[0][0]
 if abs(phi) >= 1: return np.inf
 return -np.log(2)/np.log(abs(phi))
def eg_coint_p(x, y):
 _, p, _ = coint(y, x, autolag='AIC')
 return p

# 读取收盘价 DataFrame: close_df, columns=[sym1, sym2, ...]

pairs = []
syms = close_df.columns
for i in range(len(syms)):
 for j in range(i+1, len(syms)):
 s1, s2 = syms[i], syms[j]
 x = np.log(close_df[s1]); y = np.log(close_df[s2])
 if x.corr(y) < 0.85: continue
 p = eg_coint_p(x, y)
 if p >= 0.05: continue
 beta = np.linalg.lstsq(x[:,None], y, rcond=None)[0][0]
 z = y - beta*x
 h = ou_half_life(z)
 if h > 60: continue
 score = 100*(1-p) + 50*(1-h/60)
 pairs.append((s1,s2,beta,score,h))
pairs = sorted(pairs, key=lambda x: x[3], reverse=True)
九、小结
先用相关+波动+成交三刀砍掉 90% 噪音；
协整 p 与 OU 半衰期必须双过线，任何一项不过即淘汰；
用 Score 统一排序，每周滚动重算，保证样本外稳健；
纯多头轮动即可实现“价差→份额”的积累，完全贴合 A 股制度。
