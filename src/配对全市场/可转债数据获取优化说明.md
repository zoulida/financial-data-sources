# 可转债数据获取优化说明

## 更新时间
2025-11-03

## 优化内容

### 问题
之前的可转债数据获取方式存在以下问题：
1. 需要两次API调用：先用 `w.wss` 获取 `carryingvalue`，再用 `w.wsd` 获取 `amt`
2. `w.wsd` 需要分批处理，代码复杂
3. 性能较低，API调用次数多

### 解决方案
使用 `w.wss` 一次性获取两个字段：

```python
w.wss(codes, "amt,outstandingbalance", "unit=1;tradeDate={last_trade_day};cycle=D")
```

#### 字段说明
- `amt`: 成交额（当日）
- `outstandingbalance`: 债券余额（相当于之前的 `carryingvalue`）

### 代码对比

#### 旧代码（复杂）
```python
# 先用wss获取剩余规模（carryingvalue）
cap_data = w.wss(
    codes,
    "carryingvalue",
    f"unit=1;tradeDate={last_trade_day}"
)

if cap_data.ErrorCode != 0:
    raise Exception(f"Wind API错误: ErrorCode={cap_data.ErrorCode}")

df['carrying_value'] = cap_data.Data[0]

# 使用wsd获取成交额（分批处理）
batch_size = 100
avg_amounts = []

for i in range(0, len(codes), batch_size):
    batch_codes = codes[i:i+batch_size]
    logger.info(f"查询第 {i//batch_size + 1} 批可转债成交额（日期：{last_trade_day}），共 {len(batch_codes)} 只")
    
    amt_data = w.wsd(
        ",".join(batch_codes),
        "amt",
        last_trade_day_fmt,
        last_trade_day_fmt,
        "unit=1"
    )
    
    if amt_data.ErrorCode == 0:
        avg_amounts.extend(amt_data.Data[0])
    else:
        logger.warning(f"查询第 {i//batch_size + 1} 批失败")
        avg_amounts.extend([np.nan] * len(batch_codes))

df['avg_amount'] = avg_amounts
```

#### 新代码（简洁）
```python
# 使用wss一次性获取成交额和债券余额
data = w.wss(
    codes,
    "amt,outstandingbalance",
    f"unit=1;tradeDate={last_trade_day};cycle=D"
)

if data.ErrorCode != 0:
    raise Exception(f"Wind API错误: ErrorCode={data.ErrorCode}")

# Data[0]是amt（成交额），Data[1]是outstandingbalance（债券余额）
df['avg_amount'] = data.Data[0]
df['carrying_value'] = data.Data[1]
```

### 优化效果

| 指标 | 旧方法 | 新方法 | 改进 |
|-----|--------|--------|------|
| API调用次数 | 2 + N/100（N为可转债数量） | 1 | 大幅减少 |
| 代码行数 | ~40行 | ~10行 | 减少75% |
| 分批处理 | 需要 | 不需要 | 简化逻辑 |
| 执行速度 | 慢 | 快 | 提升明显 |
| 代码可读性 | 一般 | 优秀 | 更清晰 |

### 完整的 `_fetch_convertible_bond_universe()` 函数

```python
@shelve_me_week
def _fetch_convertible_bond_universe() -> pd.DataFrame:
    """
    获取可转债池（带缓存）
    使用Wind板块成分股功能获取全部可转债
    
    Returns:
        包含可转债代码、名称、剩余规模、日均成交额的DataFrame
    """
    w.start()
    
    logger.info("开始获取可转债池数据...")
    
    # 获取所有可转债（板块ID: 1000073208000000）
    today = datetime.now().strftime('%Y-%m-%d')
    data = w.wset("sectorconstituent", f"date={today};sectorid=1000073208000000")
    
    if data.ErrorCode != 0:
        raise Exception(f"Wind API错误: ErrorCode={data.ErrorCode}")
    
    # 构建DataFrame (Data[1]是代码, Data[2]是名称)
    df = pd.DataFrame({
        'code': data.Data[1],
        'name': data.Data[2]
    })
    
    logger.info(f"获取到 {len(df)} 只可转债，正在查询成交额和债券余额...")
    
    # 获取上个交易日
    last_trade_day = getLastOpenDay(datetime.now().strftime('%Y%m%d'))
    
    codes = df['code'].tolist()
    
    # 使用wss一次性获取成交额和债券余额
    data = w.wss(
        codes,
        "amt,outstandingbalance",
        f"unit=1;tradeDate={last_trade_day};cycle=D"
    )
    
    if data.ErrorCode != 0:
        raise Exception(f"Wind API错误: ErrorCode={data.ErrorCode}")
    
    # Data[0]是amt（成交额），Data[1]是outstandingbalance（债券余额）
    df['avg_amount'] = data.Data[0]
    df['carrying_value'] = data.Data[1]
    
    logger.info(f"可转债数据获取完成")
    
    return df
```

## 测试验证

可以运行以下代码验证：

```python
from WindPy import w
from tools.tradeCal import getLastOpenDay
from datetime import datetime

w.start()

# 获取上个交易日
last_trade_day = getLastOpenDay(datetime.now().strftime('%Y%m%d'))

# 测试获取可转债数据
test_codes = ["110064.SH", "110081.SH"]
data = w.wss(
    test_codes,
    "amt,outstandingbalance",
    f"unit=1;tradeDate={last_trade_day};cycle=D"
)

if data.ErrorCode == 0:
    print(f"成交额: {data.Data[0]}")
    print(f"债券余额: {data.Data[1]}")
else:
    print(f"错误: {data.ErrorCode}")
```

## 注意事项

1. **字段名称**: `outstandingbalance` 替代了 `carryingvalue`，两者含义相同
2. **cycle=D**: 需要添加此参数以获取日度数据
3. **tradeDate**: 使用上个交易日，不需要格式转换（YYYYMMDD格式）
4. **批处理**: `w.wss` 可以一次处理所有代码，不需要分批

## 影响范围

- ✅ `data_fetcher.py` - `_fetch_convertible_bond_universe()` 函数已优化
- ✅ 性能提升 - API调用次数大幅减少
- ✅ 代码简化 - 减少约30行代码
- ✅ 维护性提升 - 逻辑更清晰

---

**状态**: ✅ 优化完成，代码更简洁高效

